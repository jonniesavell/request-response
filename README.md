# async-REST
mapping request-response to async for the web ... or is it mapping async to request-response for the web?

async is excellent for backend processes. don't block waiting for someone to do what he is good at; spend your time doing what you are good at and move your work down-stream. but the web doesn't seem to work this way. are promises a way around this? no. promises require a handle to something which governs the operation. additionally, promises imply the ability to pause, resume, and cancel operations. async operations feature nothing that governs the operation. and async operations cannot be paused, resumed, or canceled.

the web's best answer is to poll on the outcome. but mapping this request-response in the front-end of a CRUD app to the long-running async operations run in the back-end is a problem that requires a solution: how can the CRUD app in the front-end keep track of the async operations launched on its behalf?

given a resource [resource], explicitly making [resource]Request and [resource]Response persisted entities and employing correlation identifiers together solve the problem of monitoring long-running, async operations created on behalf of the front-end. you still need a worthy mechanism to serve as task queue. in the example, i have used an executor-service. longer running async operations would be better served by using a persistent distributed queue, however.

entities [resource]Request and [resource]Response are not duplicates of each other. entity [resource]Request contains the raw materials for the long-running async operations. we persist this to record the fact that the long-running async operation was created by the user of the front-end application. how many attributes beyond the correlation identifier exist within the [resource]Request entity? at a minimum, you would want the datetime on which the long-running async operation was initiated as well as the user who initiated it. it is to be noted that the sample application contains neither.

entity [resource]Response (or a subclass) contains the output (or a claim check to the output) of the long-running async operation. presumably, the operator of the front-end application has an interest in its outcome. please note that the sample application employs a subclass to hold the actual output of the operation (and a subclass to hold error information). while this complicates the design and introduces subclassing for data (as opposed to behavior), it nonetheless allows one to state that each [resource]Response is either a success or a failure; had [resource]Response been composed of output and error information, then the semantics of success XOR failure would have been lost (nothing would have prevented it from returning both or neither).

correlation identifiers are the absolute key to the monitoring of the long-running processes. we have met them before when we attempted to construct request-reply from the primitive of one way message passing. they serve us once more to correlate the user's initiation of the long-running async operation with its eventual output.

the sample code allows for the recording of exceptional conditions in a subclass of the [resource]Response entity; it is absolutely necessary that this information be recorded. if an exceptional condition occurs during the execution of a long-running async operation, then the front-end must learn of it and this is how that will occur.
